package com.bichel.java;

public class JVM {

    /*
    Java Virtual Machine (basic.JVM) is an implementation of a virtual machine which executes a Java program.
    The basic.JVM first interprets the bytecode. It then stores the class information in the memory area. Finally, it executes the bytecode generated by the java compiler.
    It is an abstract computing machine with its own instruction set and manipulates various memory areas at runtime.

    Components of the basic.JVM are:
        Class Loaders
        Run-Time Data Areas
        Execution Engine

    1. Initial tasks of the basic.JVM includes loading, verifying and linking the bytecode. Class loaders handle these tasks.

    2. The basic.JVM defines various memory areas to execute a Java program. These are used during runtime and are known as run-time data areas. Some of these areas are created on the basic.JVM start-up and destroyed when the basic.JVM exits while some are created when a thread is created and destroyed when a thread exits.
      Let's consider these areas one by one:
        Method Area
            Basically, method area is analogous to the storage area for compiled code. It stores structures such as run-time constant pool, field and method data, the code for methods and constructors as well as fully qualified class names. The basic.JVM stores these structure for each and every class.
            The method area, also known as permanent generation space (PermGen), is created when the basic.JVM starts up. The memory for this area does not need to be contiguous. All the basic.JVM threads share this memory area.
        Heap Area
            The basic.JVM allocates the memory for all the class instances and arrays from this area.
            Garbage Collector (GC) reclaims the heap memory for objects. Basically, GC has three phases to reclaim memory from objects viz. two minor GC and one major GC.
            The heap memory has three portions:
                Eden Space – it's a part of Young Generation space. When we create an object, the basic.JVM allocates memory from this space
                Survivor Space – it's also a part of Young Generation space. Survivor space contains existing objects which have survived the minor GC phases of GC
                Tenured Space – this is also known as the Old Generation space. It holds long surviving objects. Basically, a threshold is set for Young Generation objects and when this threshold is met, these objects are moved to tenured space.
            basic.JVM creates heap area as soon as it starts up. All the threads of the basic.JVM share this area. The memory for the heap area does not need to be contiguous.
        Stack area
            Stores data as frames and each frame stores local variables, partial results and nested method calls. basic.JVM creates the stack area whenever it creates a new thread. This area is private for each thread.
            Each entry in the stack is called Stack Frame or Activation record. Each frame contains three parts:
                Local Variable Array – contains all the local variables and parameters of the method
                Operand Stack – used as a workspace for storing intermediate calculation's result
                Frame Data – used to store partial results, return values for methods, and reference to the Exception table which provides corresponding catch block information in case of exceptions
            The memory for the basic.JVM stack does not need to be contiguous.
        PC Registers
            Each basic.JVM thread has a separate PC Register which stores the address of the currently executing instruction. If the currently executing instruction is a part of the native method then this value is undefined
        Native method stacks
            Native methods are those which are written in languages other than Java.
            basic.JVM provides capabilities to call these native methods. Native method stacks are also known as “C stacks”. They store the native method information. Whenever the native methods are compiled into machine codes, they usually use a native method stack to keep track of their state.
            The basic.JVM creates these stacks whenever it creates a new thread. And thus basic.JVM threads don't share this area

    3. Execution Engine
        Execution engine executes the instructions using information present in the memory areas. It has three parts:
            Interpreter
                Once classloaders load and verify bytecode, the interpreter executes the bytecode line by line. This execution is quite slow. The disadvantage of the interpreter is that when one method is called multiple times, every time new interpretation is required.
                However, the basic.JVM uses JIT Compiler to mitigate this disadvantage.
            Just-In-Time (JIT) Compiler
                JIT compiler compiles the bytecode of the often-called methods into native code at run-time. Hence it is responsible for the optimization of the Java programs.
                basic.JVM automatically monitors which methods are being executed. Once a method becomes eligible for JIT compilation, it is scheduled for compilation into machine code. This method is then known as a hot method. This compilation into machine code happens on a separate basic.JVM thread.
                As a result, it does not interrupt the execution of the current program. After compilation into machine code, it runs faster.
            Garbage Collector
                Java takes care of memory management using Garbage Collection. It's a process of looking at heap memory, identifying which objects are in use and which are not, and finally deleting unused objects.
                GC is a daemon thread. It can be called explicitly using System.gc() method, however, it won't be executed immediately and the basic.JVM decides when to invoke GC.

     */

    /*
    java -XX:+PrintCompilation
    java -XX:+UnlockDiagnosticVMOptions
    java -XX:+LogCompilation

    Ex: java -XX:+PrintCompilation StreamTask
     */

}
